module Fable.Transforms.Fable2Php

open System.IO
open Fable
open Fable.AST
open Fable.AST.Php

type IPhpCompiler =
    inherit Compiler

    abstract PhpNamespace : string
    abstract MakeUniqueVar: string -> string
    abstract AddUse : PhpType -> unit
    abstract AddType : Fable.EntityRef option * PhpType -> unit
    abstract AddImport : string * bool -> unit
    abstract AddLocalVar : string * bool -> unit
    abstract UseVar: Capture -> unit
    abstract UseVar: string -> unit
    abstract UseVarByRef: string -> unit
    abstract SetPhpNamespace: string -> unit
    abstract AddEntityName: Fable.Entity * string -> unit
    abstract ClearRequire: string -> unit
    abstract NewScope: unit -> unit
    abstract RestoreScope: unit -> Capture list
    abstract TryFindType: Fable.EntityRef -> Result<PhpType, Fable.Entity>
    abstract TryFindType: string -> PhpType option
    abstract IsThisArgument: Fable.Ident -> bool
    abstract IsImport: string -> bool option
    abstract DecisionTargets :  (Fable.Ident list * Fable.Expr) list
    abstract SetDecisionTargets :  (Fable.Ident list * Fable.Expr) list -> unit
    abstract SetThisArgument : string option -> string option
    abstract RestoreThisArgument : string option -> unit
    abstract Require : (string option * string) list
    abstract NsUse: PhpType list
    abstract EnterBreakable: string option -> unit
    abstract LeaveBreakable: unit -> unit
    abstract FindLableLevel: string -> int




module Core =
    let icomparable = { Identity = { Namespace = Some "System"; Name = "IComparable" }; Class = { Fields = []; Methods = []; BaseType = None; Interfaces = [] }; Abstract = true  }

    let traversable = { Identity = { Namespace = Some "" ; Name = "IteratorAggregate" }; Class = { Fields = []; Methods = []; BaseType = None; Interfaces = []}; Abstract = true  }


let fixExt path = Path.ChangeExtension(path, Path.GetExtension(path).Replace("js", "php").Replace("fs", "fs.php"))


/// regex to replace '$' sign that is illegal in Php to '_'. It also convert spaces '$0020' as '_'
let private charCodeEx = System.Text.RegularExpressions.Regex(@"(\$(0020)?|[^_a-zA-Z0-9])")

let (|CI|_|) (value: string) (input: string) =
    if System.String.Equals(value, input, System.StringComparison.InvariantCultureIgnoreCase) then
        Some input
    else
        None

/// fixes names generated by fable to be php safe
let private fixName (name: string) =
    match charCodeEx.Replace(name, "_") with
    | CI "empty" n -> "_" + n   // empty is a keyword in php and cannot be used in other contexts.
    | CI "parent" n -> "_" + n
    | CI "fn" n -> "_" + n
    | n -> n



let nsreplacement (ns: string) =
    ns.Split('.')
    |> Array.map( function
        | "ListModule" -> "FSharpList"
        | "ArrayModule" -> "FSharpArray"
        | "SeqModule" -> "Seq"
        | "SeqModule2" -> "Seq2"
        | CI "List" n 
        | CI "Array" n 
        | CI "fn" n -> "_" + n 
        | ns -> ns)
    |> String.concat @"\"

let ident name =
    { Name = name; Namespace = None; }

let nsIdent ns name =
    { Namespace = Some (nsreplacement ns); Name = name}


let getEntityIdent (ent: Fable.Entity) =
    match ent with
    | :? Fable.Transforms.FSharp2Fable.FsEnt as fs ->
        nsIdent fs.FSharpEntity.AccessPath (fixName fs.FSharpEntity.CompiledName)
    | _ -> ident (ent.DisplayName)

let getEntityRefIdent (com: IPhpCompiler) (e: Fable.EntityRef) =
    com.GetEntity e
    |> getEntityIdent

let  removeLocalNs (com: IPhpCompiler) (e: PhpIdentity) =
    if e.Namespace = Some com.PhpNamespace then
        { e with Namespace = None}
    else
        e



/// generate name for DU case
/// For single case union, it just take the name
/// For multicase unions, it prepend the DU name (The same case name can be defined
/// in multiple DUs. In F# it is disambiguated by prefixing - DU.Case - This cannot
/// be done in Php)
let caseName (com: IPhpCompiler) (entity: Fable.Entity) (case: Fable.UnionCase) =
    if entity.UnionCases.Length = 1 then
        getEntityIdent entity

    else
        let caseIdent = getEntityIdent entity
        { caseIdent with Name = caseIdent.Name + "_" + fixName case.Name }


/// find the case name from a Tag.
/// Used to instanciate DU cases as classes instances.
let caseNameOfTag ctx (entity: Fable.Entity) tag =
    caseName ctx entity entity.UnionCases.[tag]

let phpObj = ident "object"
let phpString = ident "string"
let phpInt = ident "int"
let phpFloat = ident "float"
let phpBool = ident "bool"
let phpChar = ident "char"
let phpVoid = ident "void"

let phpThis = PhpVar "this"
let call fn args = PhpCall(fn, args )

let phpMember this name typ = PhpMember(PhpExprMember this, name, typ)
let phpField this name = phpMember this name PhpField
let callfn name args = PhpCall(PhpIdent (ident name), args)
let callmethod this name args = PhpCall(phpMember this name PhpMethod , args)


let phpIsNull phpExpr = callfn "is_null" [phpExpr]
let getTag this = callmethod this "get_Tag" []

let assign target value =
    PhpBinaryOp("=", target, value)

let doAssign target value =
    match value with
    | PhpUnaryOp( "(void)", expr) ->
        // this is a 'value = expr |> ignore' ... just emit expr
        PhpDo(expr)
    | _ -> PhpDo(assign target value)


let makeFun name args body =
    { Name = name; Args =  args; Body = body }

let makeMethod' name args body isStatic =
    { Fun = makeFun name args body ; Static = isStatic }

let makeMethod name args body =
    makeMethod' name args body false

let phpArg name = { Name = name; Kind = PhpMandatoryArg }

/// convert fable type of Php type name for type comparison (instanceof)


let convertMultiCaseUnion (com: IPhpCompiler) (decl: Fable.ClassDecl) (info: Fable.Entity) =
    let id = getEntityIdent info
    let baseType =
            { Identity = id
              Class = {
                  Fields = []
                  Methods = []
                  BaseType = None
                  Interfaces = [] }

              Abstract = true
              }

    let caseTypes =
        [
          for i, case in Seq.indexed info.UnionCases do
            let t =
                let id = caseName com info case
                { Identity = id
                  Class =
                    {
                      Fields = [ for e in case.UnionCaseFields -> fixName e.Name ]
                      Methods =
                          [ makeMethod "__construct" [ for e in case.UnionCaseFields -> { Name = fixName e.Name; Kind = Php.PhpMandatoryArg } ]
                                        [ for e in case.UnionCaseFields ->
                                            let name = fixName e.Name
                                            doAssign (phpField phpThis name) (PhpVar name ) ]


                            makeMethod "get_FSharpCase" [] [ PhpStatement.PhpReturn(PhpConst(PhpConstString(case.Name)))]
                            makeMethod "get_Tag" [] [ PhpStatement.PhpReturn(PhpConst(PhpConstNumber (float i)))]
                            makeMethod "CompareTo" [ phpArg "other"]
                                      [ let cmp = PhpVar (com.MakeUniqueVar "cmp")
                                        doAssign cmp
                                            (PhpTernary( PhpBinaryOp(">",
                                                            getTag phpThis ,
                                                            getTag (PhpVar "other") ),
                                                            PhpConst(PhpConstNumber 1.),
                                                               PhpTernary(
                                                                   PhpBinaryOp("<",
                                                                       getTag phpThis,
                                                                       getTag (PhpVar "other")),
                                                                       PhpConst(PhpConstNumber -1.),
                                                                        PhpConst(PhpConstNumber 0.))))
                                        if List.isEmpty case.UnionCaseFields then
                                            PhpStatement.PhpReturn(cmp)
                                        else
                                            PhpIf(PhpBinaryOp("!=", cmp, PhpConst(PhpConstNumber 0.) ),
                                                [PhpStatement.PhpReturn cmp],
                                                []
                                            )
                                            for e in case.UnionCaseFields do
                                                let cmp = PhpVar(com.MakeUniqueVar "cmp")
                                                let fieldName = fixName e.Name
                                                match e.FieldType with
                                                | Fable.Type.Number _ ->
                                                    doAssign cmp
                                                        (PhpTernary( PhpBinaryOp(">",
                                                                        phpField phpThis fieldName,
                                                                        phpField (PhpVar "other") fieldName ),
                                                                        PhpConst(PhpConstNumber 1.),
                                                                           PhpTernary(
                                                                               PhpBinaryOp("<",
                                                                                   phpField phpThis fieldName,
                                                                                   phpField (PhpVar "other") fieldName),
                                                                                   PhpConst(PhpConstNumber -1.),
                                                                                    PhpConst(PhpConstNumber 0.)


                                                       ) ) )
                                                | _ ->
                                                    doAssign cmp
                                                        (callmethod (phpField phpThis fieldName) "CompareTo"
                                                                  [phpField(PhpVar "other") fieldName ])

                                                PhpIf(PhpBinaryOp("!=", cmp, PhpConst(PhpConstNumber 0.) ),
                                                    [PhpStatement.PhpReturn cmp],
                                                    []
                                                )
                                            PhpStatement.PhpReturn (PhpConst (PhpConstNumber 0.))
                                      ]

                          ]
                      BaseType = Some baseType.Identity
                      Interfaces = [ Core.icomparable ]
                      }
                  Abstract = false
                }

            com.AddUse(Core.icomparable)
            com.AddType(None, t)
            PhpType t ]
    { Namespace = id.Namespace
      Decls = [ yield PhpType baseType
                yield! caseTypes]}



/// Return strategy for expression compiled as statements
/// F# is expression based, but some constructs have to be transpiled as
/// statements in other languages. This types indicates how the result
/// should be passed to the resto of the code.
type ReturnStrategy =
      /// The statement should return the value
    | Return
      /// The statement should define a new variable and assign it
    | Let of string
      /// No return value
    | Do
      /// used in decision tree when multiple cases result in the same code
    | Target of string






let libCall (com: IPhpCompiler) file ns memberName args =
    let moduleName = ns

    PhpCall(PhpIdent (nsIdent moduleName memberName), args)


let fcallFn name args t r =
    (Fable.Call(Fable.IdentExpr ({ Name = name; IsCompilerGenerated = false; Type = Fable.Any; IsMutable = false; IsThisArgument = false; IsOptional = false; Range = None }),
        { ThisArg = None
          Args = args
          SignatureArgTypes = []
          CallMemberInfo = Some 
            { CompiledName = name
              CurriedParameterGroups = [ [ for p in args ->  { Name = None; Type = p.Type } ] ]
              DeclaringEntity = None
              FullName = name
              IsInstance = false
            }
          HasSpread = false
          IsJsConstructor = false }, t,r ))


let replacements (expr: Fable.Expr) =
    match expr with
    | Fable.Call(Fable.Get(Fable.IdentExpr( { Name = "Math"}), Fable.FieldGet(fn, _), _,_), info, t, r) ->
        fcallFn fn info.Args t r
        |> Some

    | Fable.Get(callee, Fable.FieldGet("length",_), t, r) ->
        match callee.Type with
        | Fable.String ->
            fcallFn "strlen" [callee] t r
            |> Some
        | Fable.Array _ ->
            fcallFn "count" [callee] t r
            |> Some
        | _ -> None
    | Fable.Call(Fable.Get(callee, Fable.FieldGet("toString",_), _, _), info, t ,r) ->
        match callee.Type with
        | Fable.Number _ ->
            fcallFn "strval" [callee] t r
            |> Some
        | _ -> None

    | Fable.Operation(Fable.Binary(BinaryEqual, value, Fable.Value(Fable.Null Fable.Any, _)), t, r) ->
        fcallFn "is_null" [value] t r
        |> Some


    //| PhpMember(PhpExprMember this, "length",PhpMemberType.PhpField ) ->
    //    match fableType with
    //    | Fable.String ->
    //            //    | Fable.Array _ ->
    //        callfn "count" [this]
    //    | _ -> phpExpr
    //| expr -> expr
    | _ -> None

let instanceof phpExpr ident =
    PhpBinaryOp("instanceof", phpExpr, PhpIdent ident)

/// convert a test (expression that returns a boolean) to a Php construct
let convertTest (com: IPhpCompiler)  test phpExpr =

    match test with
    | Fable.TestKind.UnionCaseTest(tag) ->
        // union test case is implemented with a ->get_Tag() test
        PhpBinaryOp("===", getTag phpExpr, PhpConst(PhpConstNumber(float tag)))
    | Fable.TestKind.ListTest(isCons) ->
        // list test is implemented with a instanceof Cons / instanceof Nil test
        if isCons then
            PhpUnaryOp("!", libCall com "List" "FSharpList" "isEmpty" [phpExpr])
        else
            libCall com "List" "FSharpList" "isEmpty" [phpExpr]
            //com.AddUse(PhpList.nil)
            //PhpInstanceOf(phpExpr, InType PhpList.nil)
    | Fable.OptionTest(isSome) ->
        // option is implementd using null, test is implemented with a is_null call
        if isSome then
            PhpUnaryOp("!",phpIsNull phpExpr)
        else
            phpIsNull  phpExpr
    | Fable.TypeTest(t) ->
        // use instanceof
        match t with
        | Fable.Type.Array _ ->
            callfn "is_array" [phpExpr]
        | Fable.String -> callfn "is_string" [phpExpr]
        | Fable.Number ((Int32|Int16|Int8|UInt16|UInt32|UInt8), _) -> callfn "is_int" [phpExpr]
        | Fable.Number ((Float32 | Float64), _) -> callfn "is_float" [phpExpr]
        | Fable.Boolean  -> callfn "is_bool" [phpExpr]
        | Fable.Char  -> callfn "is_string" [phpExpr]
        | Fable.AnonymousRecordType _ -> failwith "not supported"
        | Fable.Any -> callfn "is_set" [phpExpr]
        | Fable.DelegateType _ -> callfn "is_callable" [phpExpr]
        | Fable.LambdaType _ -> callfn "is_callable" [phpExpr]
        | Fable.GenericParam _ -> failwith "not supported"
        | Fable.Enum ref ->
            let ident =
                match com.TryFindType(ref) with
                | Ok phpType -> phpType.Identity
                | Error ent -> (getEntityIdent ent)
            instanceof phpExpr ident
        | Fable.List _ -> instanceof phpExpr (nsIdent "FSharpList" "FSharpList")
        | Fable.Option(t,_) -> failwithf "not supported"
        | Fable.DeclaredType(ref, _) ->
            let ident =
                match com.TryFindType(ref) with
                | Ok phpType -> phpType.Identity
                | Error ent -> getEntityIdent ent
            instanceof phpExpr ident
        | Fable.MetaType ->
            failwithf "MetaType not supported"
        | Fable.Regex ->
            failwithf "Regex not supported"
        | Fable.Tuple _ ->
            callfn "is_array" [phpExpr]
        | Fable.Unit ->
            failwithf "not supported"
        | Fable.Measure _ ->
            failwithf "not supported"

/// convert a Fable expression to a Php expression
let rec convertExpr (com: IPhpCompiler) (expr: Fable.Expr) =
    match expr with
    | Fable.NativeInstruction _ -> failwith "TODO: Native instruction"

    | Fable.Value(value,range) ->
        // this is a value (number / record instanciation ...)
        convertValue com value range

    | Fable.Operation(Fable.Binary(op, left,right), t, _) ->
        // the result of a binary operation
        match replacements expr with
        | Some newExpr -> convertExpr com newExpr
        | None ->

            let phpOp opstr = PhpBinaryOp(opstr, convertExpr com left, convertExpr com right)

            match op with
            | BinaryOperator.BinaryMultiply -> phpOp "*"
            | BinaryOperator.BinaryPlus ->
                match t with
                | Fable.Type.String -> phpOp "."          // Php string concatenation is done with '.'
                | _ -> phpOp "+"
            | BinaryOperator.BinaryMinus -> phpOp "-"
            | BinaryOperator.BinaryLess -> phpOp "<"
            | BinaryOperator.BinaryGreater -> phpOp ">"
            | BinaryOperator.BinaryLessOrEqual -> phpOp "<="
            | BinaryOperator.BinaryGreaterOrEqual -> phpOp ">="
            | BinaryOperator.BinaryAndBitwise -> phpOp "&"
            | BinaryOperator.BinaryOrBitwise -> phpOp "|"
            | BinaryOperator.BinaryXorBitwise -> phpOp "^"
            | BinaryOperator.BinaryEqual -> phpOp "=="
            | BinaryOperator.BinaryUnequal -> phpOp "!="
            | BinaryOperator.BinaryEqualStrict -> phpOp "==="
            | BinaryOperator.BinaryUnequalStrict -> phpOp "!=="
            | BinaryOperator.BinaryModulus -> phpOp "%"
            | BinaryOperator.BinaryDivide -> phpOp "/"
            | BinaryOperator.BinaryExponent -> phpOp "**"
            | BinaryOperator.BinaryShiftLeft -> phpOp "<<"
            | BinaryOperator.BinaryShiftRightSignPropagating -> phpOp ">>"
            | BinaryOperator.BinaryShiftRightZeroFill -> libCall com "FSharp.Core"  "FSharp.Core" "lsr"  [convertExpr com left; convertExpr com right]
            | BinaryOperator.BinaryIn -> failwithf "BinaryIn not supported"
            | BinaryOperator.BinaryInstanceOf -> failwithf "BinaryInstanceOf not supported"
    | Fable.Operation(Fable.Unary(op, expr),_,_) ->
        let phpOp opStr = PhpUnaryOp(opStr, convertExpr com expr)

        // the result of an unary operation
        match op with
        | UnaryOperator.UnaryVoid ->
            // there is no void function in Php. One in defined in FSharp.Core.php
            // it takes a value and returns nothing
            PhpUnaryOp("(void)", convertExpr com expr)
        | UnaryOperator.UnaryNot -> phpOp "!"
        | UnaryOperator.UnaryMinus -> phpOp "-"
        | UnaryOperator.UnaryPlus -> phpOp "+"
        | UnaryOperator.UnaryNotBitwise -> phpOp "~~~"
        | UnaryOperator.UnaryDelete -> failwith "UnaryDelete not supported"
        | UnaryOperator.UnaryTypeof -> callfn "gettype" [convertExpr com expr]

    | Fable.Operation(Fable.Logical(op, left, right),_,_) ->
        // this is a binary logical operation
        let opstr =
            match op with
            | LogicalOperator.LogicalAnd -> "&&"
            | LogicalOperator.LogicalOr -> "||"
        PhpBinaryOp(opstr, convertExpr com left, convertExpr com right)


    | Fable.Expr.Call(callee, { ThisArg = None; Args = args; CallMemberInfo = info }  , ty,_) ->
        // static function call
        
        match replacements expr with
        | Some expr -> convertExpr com expr
        | None ->
            match callee with
            | Fable.Get(this, Fable.FieldGet(field, _),_,_) ->
                match this with
                | Fable.Value(Fable.Null _, _) ->
                    callfn (fixName field) (convertArgs com args)
                | _ ->
                    match info with
                    | Some { IsInstance = true} ->
                        callmethod (convertExpr com this) (fixName field) (convertArgs com args)
                    | _ ->
                        call (phpField (convertExpr com this) (fixName field)) (convertArgs com args)

            | Fable.Get(target , Fable.ExprGet(Fable.Value(Fable.StringConstant m, _)),_,_) ->
                // convert calls on Array object by string key.
                // in Php $a['Hello'] is equivalent to $a->Hello, we choose this representation.
                callmethod (convertExpr com target)  (fixName m) (convertArgs com args)

            | Fable.IdentExpr(id) when id.DisplayName = "( .ctor )" ->
                // this is a ctor
                let classId =
                    match ty with
                    | Fable.DeclaredType(entref,_) ->
                        getEntityRefIdent com entref
                    | _ ->
                        failwith "Not implemented"
                PhpNew (classId, convertArgs com args)
            | Fable.IdentExpr(id) ->

                match id.Type with
                | Fable.Any ->
                    match info with
                    | Some { DeclaringEntity = Some _ } ->
                        //let ns = info.FullName.Substring(0, max 0 (info.FullName.LastIndexOf('.')))

                        call (PhpIdent (ident (fixName id.Name) )) (convertArgs com args)
                    | _ ->
                        call (PhpIdent (nsIdent "" (fixName id.Name) )) (convertArgs com args)

                | Fable.LambdaType(_,_)
                | Fable.DelegateType(_,_) ->
                        let name = fixName id.Name
                        com.UseVarByRef(name)
                        call (PhpVar name) (convertArgs com args)
                | Fable.Type.DeclaredType (e, _)  ->
                    getEntityRefIdent com e |> PhpIdent
                | _ ->
                    failwith "Nope"




            | _ ->
                // simply call the function
                let phpCallee = convertExpr com callee
                match phpCallee with
                | PhpVar name ->
                    // is a call to a function by value,
                    // add a byref use to make recursive function work
                    // in Php recursive functions have to declare their own use:
                    // $loop = function ($arg) use (&$loop) { ... }
                    // it has to be byref to enable outer scope variable mutations
                    com.UseVarByRef(name)
                | _ -> ()


                call phpCallee (convertArgs com args)

    | Fable.Expr.Call(callee, { ThisArg = Some this; Args = args; CallMemberInfo = info  }, _,_) ->
        // call to a member in the same namespace
        match replacements expr with
        | Some newExpr -> convertExpr com newExpr
        | None ->
            let methodName =
                match callee with
                | Fable.Import({ Selector = name},_,_) ->
                    fixName name
                | Fable.IdentExpr ident ->
                    fixName ident.Name
                | _ ->
                    failwith "Not supported"

            callfn methodName (convertArgs com (this :: args))


    | Fable.CurriedApply(callee, args,_,_) ->
        match replacements expr with
        | Some newExpr -> convertExpr com newExpr
        | None ->
            // converted to a simple Php function call
            call (convertExpr com callee)  (convertArgs com args)

    | Fable.Emit(info,_,_) ->
        // convert to Php macro preparing replacements
        // see in the Printer to see how it's handled
        PhpMacro(info.Macro,
            [
              match info.CallInfo.ThisArg with
              | Some this ->
                convertExpr com this
              | None -> ()
              for arg in info.CallInfo.Args do
                convertExpr com arg])
    | Fable.Get(callee, kind ,typ,_) ->
        // this is a value access
        let phpExpr = convertExpr com callee

        match kind with
        | Fable.UnionField(caseIndex, fieldIndex) ->
            // had to add the field info (and not only the index)
            // because we implement Cases as classes (contrary to JS where cases are arrays)
            match callee.Type with
            | Fable.DeclaredType(entRef, _) -> Some entRef
            | _ -> None
            |> Option.bind (fun entRef ->
                let ent = com.GetEntity(entRef)
                List.tryItem caseIndex ent.UnionCases)
            |> Option.bind (fun unionCase -> unionCase.UnionCaseFields |> List.tryItem fieldIndex)
            |> Option.map (fun field -> phpField phpExpr (fixName field.Name))
            |> Option.defaultWith (fun _ -> failwith "Cannot find union field name")
        | Fable.OptionValue ->
            // option is simply erased
            if mustWrapOption typ then
                libCall com "Option" "Option" "value" [ phpExpr]
            else
                phpExpr
        | Fable.FieldGet(name, _) ->
            match replacements expr with
            | Some newExpr -> convertExpr com newExpr
            | None ->
                phpField phpExpr (fixName name)

        | Fable.GetKind.TupleIndex(id) ->
            // this is a tuple value access. Tuples are transpiled as arrays
            PhpArrayAccess(phpExpr, PhpConst(PhpConstNumber (float id)))
        | Fable.ExprGet expr' ->
            // the access key is an expression
            let prop = convertExpr com expr'
            PhpArrayAccess(phpExpr, prop)

        | Fable.ListHead ->
            // This access cons->Value field in a list node
            libCall com "List" "FSharpList" "head" [ phpExpr ]
        | Fable.ListTail ->
            // this acess cons->Next field in a list node
            libCall com "List" "FSharpList" "tail" [ phpExpr ]
        | Fable.UnionTag ->
            // this calls get_Tag on an union
            getTag phpExpr

    | Fable.IdentExpr(id) ->
        // this is an identifier

        if com.IsThisArgument(id) then
            // fable doesn't keep track of 'this'
            // when entering a method, we put the identifier for 'this' in the context
            // and check it here for replacement

            phpThis
        else
            // this is a standard identifier access
            let name = fixName id.Name

                    // indicates the value is used (for capture)
            if id.IsMutable then
                com.UseVarByRef(name)
            else
                com.UseVar(name)

            match com.IsImport name with
            | Some true ->
                PhpCall(PhpIdent (ident name), [])
            | Some false ->
                PhpIdent (ident name)
            | None ->
                PhpVar name
    | Fable.Import(info,t,_) ->
        // this is an import

        match info.ImportTarget with
        | Fable.FunctionTarget ns ->
            PhpIdent (nsIdent ns (fixName info.Selector))
        | Fable.AttributeImportTarget ->
            PhpIdent (ident (fixName info.Selector))
        | Fable.CtorTarget ctor ->
            PhpIdent (nsIdent ctor.Namespace (fixName ctor.ClassName))


        | Fable.EntityTarget ent ->
            let ns =
                match ent.Ref.SourcePath with
                | Some paht -> com.GetRootModule paht
                | None -> ""

            PhpIdent (nsIdent ns (fixName ent.DisplayName))
        | Fable.InstanceMemberTarget  _ ->
            PhpIdent(ident (fixName info.Selector))
        | Fable.StaticMemberTarget ent ->
            //let id = getEntityIdent ent

            //PhpMember(PhpIdentMember id, fixName info.Selector, PhpMethod)
            let ns = 
                match ent with
                | :? Fable.Transforms.FSharp2Fable.FsEnt as fs ->
                    fs.FSharpEntity.AccessPath
                | _ -> ""
                
            PhpCall(PhpIdent (nsIdent ns (fixName info.Selector)),[])
        | Fable.ValueTarget ns ->
            PhpCall(PhpIdent (nsIdent ns (fixName info.Selector)),[])

    | Fable.DecisionTree(expr,targets) ->
        // converts a decision tree.
        // it defines some targets that will be referenced inside expr
        // by DecistionTreeSuccess(index, ... ) nodes
        // we add these targets to local compiler context (after
        // saving targets from outer scope)
        let outerTargets = com.DecisionTargets
        // and set the local targets
        com.SetDecisionTargets (targets)
        let phpExpr = convertExpr com expr
        com.SetDecisionTargets(outerTargets)
        phpExpr

    | Fable.IfThenElse(guard, thenExpr, elseExpr,_) ->
        // when converting as an expression, a IfThenElse F# expre
        // is transpiled to a Php Ternary 'guard ? thenExpr : elseExpr'
        PhpTernary(convertExpr com guard,
                   convertExpr com thenExpr,
                   convertExpr com elseExpr )


    | Fable.Test(expr, test , _ ) ->
        // this is a test expression (see convertTest)
        convertExpr com expr
        |> convertTest com test

    | Fable.DecisionTreeSuccess(index,[],_) ->
        // the index indicates which condition target to jump too
        // here there is no variable bindings, so the expression
        // can just be transpiled in place
        let _,target = com.DecisionTargets.[index]
        convertExpr com target
    | Fable.DecisionTreeSuccess(index,boundValues,_) ->
        // in this version, there are variable bindings that make it multi statement
        // To circumvent the fact that Php has no comma operator, we embed the whole
        // thing in an anonymous function that is instantly executed:
        //  | x,y -> x + y
        // is conceptually transpiled to
        // (function () use ($match) {
        //      $x = $match[0];
        //      $y = $match[1];
        //      return $x + $y }) ()

        // find the target and associated bindings
        let bindings,target = com.DecisionTargets.[index]

        // convert bound values expressions
        let args = List.map (convertExpr com) boundValues

        // prepare the scope for the anonymous function
        com.NewScope()
        // declare bound value usage in scope
        for id in bindings do
            com.AddLocalVar(fixName id.Name, id.IsMutable)
        // convert body
        let body = convertExprToStatement com target Return

        let uses = com.RestoreScope()
        // create anonymous function and call it with args
        call
            (PhpAnonymousFunc([ for id in bindings -> fixName id.Name ], uses, body))
            args


    | Fable.ObjectExpr(members, t, baseCall) ->
        // this is an object ceation expr and is compiled as
        // an array with string keys.
        PhpAnonymousClass {
            Fields = []

            Methods = [ for m in members do
                            match m with
                            | { Args=[]; Body = Fable.Delegate(args, body, _) } ->
                                yield { m with Args = { Name = "this"; Type = Fable.Any; IsMutable = false; IsThisArgument = true; IsCompilerGenerated = true; IsOptional = false; Range = None } ::  args; Body = body;  }
                                        |> convertMemberDecl com
                            | _ ->
                                yield convertMemberDecl com m ]
            BaseType = None
            Interfaces = []

        }

    | Fable.Expr.Lambda(arg,body,_) ->
        // lambda is transpiled as a function
        convertFunction com body [arg]

    | Fable.Expr.Delegate(args, body, _) ->
        // delegates are also tanspiled as functions
        convertFunction com body args

    | Fable.Let(id, expr, body) ->
        // this defines a name id for the expression expr that is used in body
        // let x = expr in body
        // to transpile it to an expression, we consider it as:
        // (fun x -> body) expr
        // and transpile it as:
        // (function ($x) { ... body ... }) ($expr)

        // convert expr in outer scope
        let phpExpr = convertExpr com expr
        // open new scope
        com.NewScope()
        // add $x to local var (in case of inner capture)
        com.AddLocalVar(fixName id.Name, id.IsMutable)
        // convert body in inner scope
        let phpBody = convertExprToStatement com body Return
        // close scope and get captures variables
        let uses = com.RestoreScope()
        call (PhpAnonymousFunc([id.Name], uses , phpBody))
             [phpExpr]

    | Fable.Expr.TypeCast(expr, t,_) ->
        // for now we ignore casts... should probably be improved
        convertExpr com expr

    | Fable.Expr.Sequential([Fable.Value(Fable.UnitConstant, _) ; body]) ->
        // a sequènce of a unit and a body... just get rid of the Unit.
        convertExpr com body

    | Fable.Expr.Sequential(_) ->
        // this is a multi part/sequential expression
        // as before, this doesn't exist in Php, so we convert it to multiple
        // statements inside an anonymous function
        // (doSomething();y)  is valid in F# an have a value 'y'
        // it is converted to
        // (function () { doSomething(); retrun y; })()

        // open scope for the function
        com.NewScope()
        // convert body as statements with 'Return' strategy
        let body = convertExprToStatement com expr Return
        // close the scope and get captured vars
        let uses = com.RestoreScope()
        call (PhpAnonymousFunc([], uses, body))
            []

    | Fable.Curry(expr, arrity) ->
        failwith "Curry is not implemented"

    | Fable.LetRec(bindings, body) ->
        failwith "LetRec is not implemented"
    | Fable.ForLoop _
    | Fable.WhileLoop _
    | Fable.Set _
    | Fable.TryCatch _ ->
        // these constructs should always be embeded in a function
        // and converted using the convertExprToStatement
        failwith "Should not appear in expression"

    /// convert a list of arguments
and convertArgs com (args: Fable.Expr list) =
    [ for arg in args do
        match arg.Type with
        | Fable.Unit -> () // remove Unit passed by value
        | _ -> convertExpr com arg
    ]


and convertFunction (com: IPhpCompiler)  body (args: Fable.Ident list) : PhpExpr =
    com.NewScope()
    let args =
        [ for arg in args do
            if arg.Type <> Fable.Unit then
                let argName = fixName arg.Name
                com.AddLocalVar(argName, arg.IsMutable)
                argName ]

    let strategy =
        match body.Type with
        | Fable.Unit -> Do
        | _ -> Return

    let phpBody = convertExprToStatement com body strategy

    let uses = com.RestoreScope()
    PhpAnonymousFunc(args, uses , phpBody )

and convertValue (com: IPhpCompiler)  (value: Fable.ValueKind) range =
    match value with
    | Fable.NewUnion(args,tag,ent,_) ->
        let ent = com.GetEntity(ent)
        let t = caseNameOfTag com ent tag |> removeLocalNs com

        PhpNew(t, [for arg in args do convertExpr com arg ])
    | Fable.NewTuple(args,_) ->

        PhpNewArray([for arg in args do (PhpArrayNoIndex, convertExpr com arg)])
    | Fable.NewRecord(args, e , _) ->
        let t = getEntityRefIdent com e |> removeLocalNs com

        PhpNew( t, [ for arg in args do convertExpr com arg ] )


    | Fable.NumberConstant(v,_,_) ->
        PhpConst(PhpConstNumber v)
    | Fable.StringConstant(s) ->
        PhpConst(PhpConstString s)
    | Fable.BoolConstant(b) ->
        PhpConst(PhpConstBool b)
    | Fable.UnitConstant ->
        PhpConst(PhpConstNull)
    | Fable.CharConstant(c) ->
        PhpConst(PhpConstString (string c))
    | Fable.EnumConstant(e,ref) ->
        convertExpr com e
    | Fable.Null _ ->
        PhpConst(PhpConstNull)
    | Fable.NewList(Some(head,tail),_) ->
        libCall com "List" "FSharpList" "cons" [ convertExpr com head; convertExpr com tail]
    | Fable.NewList(None,_) ->
        libCall com "List" "FSharpList" "_empty" []
    | Fable.NewArray(values,_) ->
        PhpNewArray([for v in values -> (PhpArrayNoIndex, convertExpr com v)])

    | Fable.NewOption(opt,t,_) ->
        match opt with
        | Some expr ->
            if mustWrapOption t then
                libCall com "Option" "Option" "some" [ convertExpr com expr]
            else
                convertExpr com expr
        | None -> PhpConst(PhpConstNull)
    | Fable.NewAnonymousRecord(values, fields, _ ) ->
        PhpNewArray[ for i in 0 .. values.Length - 1 do
                        PhpArrayString fields.[i], convertExpr com values.[i] ]
    | Fable.BaseValue(ident,_) ->
        match ident with
        | None -> failwith "Not suppoerted" //  PhpParent
        | Some ident -> convertExpr com (Fable.IdentExpr ident)
    | Fable.NewArrayFrom(arg,_) ->
        match arg.Type with
        | Fable.Number _ ->

            match arg with
            | Fable.Value (Fable.NumberConstant(0., _,_), _) ->
                PhpNewArray []
            | _->
                callfn "array_fill" [PhpConst (PhpConstNumber 0.); convertExpr com arg]
        | _ ->
        callfn "iterator_to_array" [ convertExpr com arg ]
    | Fable.RegexConstant(source, flags) ->
        let modifiers =
            flags
            |> List.map (function
                | RegexIgnoreCase -> "i"
                | RegexMultiline -> "m"
                | RegexGlobal ->
                    addWarning com [] range "Regex global flag is not supported in Php"
                    ""
                | RegexSticky ->
                    addWarning com [] range "Regex sticky flag is not supported in Php"
                    ""
                )
            |> String.concat ""
        PhpConst (PhpConstString( "/" + source + "/" +  modifiers))
    | Fable.ThisValue _ ->
        phpThis
    | Fable.TypeInfo _ ->
        failwith "Not implemented"


and canBeCompiledAsSwitch evalExpr tree =
    match tree with
    | Fable.IfThenElse(Fable.Test(caseExpr, Fable.UnionCaseTest(tag),_), Fable.DecisionTreeSuccess(index,_,_), elseExpr,_)
        when caseExpr = evalExpr ->
        canBeCompiledAsSwitch evalExpr elseExpr
    | Fable.DecisionTreeSuccess(index, _,_) ->
        true
    | _ -> false


and findCasesNames evalExpr tree =
    [ match tree with
      | Fable.IfThenElse(Fable.Test(caseExpr, Fable.UnionCaseTest(tag),_), Fable.DecisionTreeSuccess(index,bindings,_), elseExpr,_)
            when caseExpr = evalExpr ->
            Some tag, bindings, index
            yield! findCasesNames evalExpr elseExpr
      | Fable.DecisionTreeSuccess(index, bindings,_) ->
            None, bindings, index
      | _ -> ()
    ]

and hasGroupedCases indices tree =
    match tree with
    | Fable.IfThenElse(Fable.Test(_, _, _), Fable.DecisionTreeSuccess(index,_,_), elseExpr,_) ->
        if Set.contains index indices then
            true
        else
            hasGroupedCases (Set.add index indices) elseExpr
    | Fable.DecisionTreeSuccess(index, _, _) ->
        if Set.contains index indices then
            true
        else
            false
    | Fable.IfThenElse(Fable.Test(_, _, _), _,_,_) ->
        false
    | _ ->
        failwithf "Invalid Condition AST"

and getCases cases tree =
    match tree with
    | Fable.IfThenElse(Fable.Test(_, _, _), Fable.DecisionTreeSuccess(index,boundValues,_), elseExpr,_) ->
        getCases (Map.add index boundValues cases) elseExpr
    | Fable.DecisionTreeSuccess(index, boundValues, _) ->
        Map.add index boundValues cases
    | Fable.IfThenElse(Fable.Test(_, _, _), _,_,_) ->
        cases
    | _ ->
        failwithf "Invalid Condition AST"


and convertMatching (com: IPhpCompiler) input guard thenExpr elseExpr expr returnStrategy =
    if (canBeCompiledAsSwitch expr input) then
        let tags = findCasesNames expr input
        let inputExpr = convertExpr com expr
        [ PhpSwitch(getTag inputExpr,
            [ for tag,bindings, i in tags ->
                let idents,target = com.DecisionTargets.[i]
                let phpCase =
                    match tag with
                    | Some t -> Some (PhpConst (PhpConstNumber (float t)))
                    | None -> None


                phpCase,
                    [ for ident, binding in List.zip idents bindings do
                        com.AddLocalVar(fixName ident.Name, ident.IsMutable)
                        doAssign (PhpVar(fixName ident.Name)) (convertExpr com binding)
                      match returnStrategy with
                      | Target t ->
                            com.AddLocalVar(fixName t, false)
                            doAssign (PhpVar(fixName t)) (PhpConst(PhpConstNumber(float i)))
                            PhpBreak None
                      | Return _ ->
                            yield! convertExprToStatement com target returnStrategy
                      | _ ->
                            yield! convertExprToStatement com target returnStrategy
                            PhpBreak None
                    ]]
            )

        ]
    else
        [ PhpIf(convertExpr com guard, convertExprToStatement com thenExpr returnStrategy, convertExprToStatement com elseExpr returnStrategy) ]

and convertExprToStatement (com: IPhpCompiler) expr returnStrategy =
    match expr with
    | Fable.DecisionTree(input, targets) ->

        let upperTargets = com.DecisionTargets
        com.SetDecisionTargets(targets)
        let phpExpr = convertExprToStatement com input returnStrategy
        com.SetDecisionTargets(upperTargets)
        phpExpr
    | Fable.IfThenElse(Fable.Test(expr, Fable.TestKind.UnionCaseTest(tag), _) as guard, thenExpr , elseExpr, _) as input ->
        let groupCases = hasGroupedCases Set.empty input
        if groupCases then
            let targetName = com.MakeUniqueVar("target")
            let targetVar = PhpVar targetName
            let switch1 = convertMatching com input guard thenExpr elseExpr expr (Target targetName)

            let cases = getCases Map.empty input
            let switch2 =
                PhpSwitch(targetVar,
                    [ for i, (idents,expr) in  List.indexed com.DecisionTargets do
                        Some(PhpConst (PhpConstNumber (float i))), [
                            match Map.tryFind i cases with
                            | Some case ->
                                // Assigns have already been made in switch 1
                                yield! convertExprToStatement com expr returnStrategy
                            | None -> ()
                            match returnStrategy with
                            | Return _ -> ()
                            | _ -> PhpBreak None;
                        ]

                    ]
                )
            switch1 @ [ switch2 ]

        else
            convertMatching com input guard thenExpr elseExpr expr returnStrategy


    | Fable.IfThenElse(guardExpr, thenExpr, elseExpr, _) ->
        let guard = convertExpr com guardExpr

        [ PhpIf(guard, convertExprToStatement com thenExpr returnStrategy,
                    convertExprToStatement com elseExpr returnStrategy) ]
    | Fable.DecisionTreeSuccess(index,boundValues,_) ->
        match returnStrategy with
        | Target target -> [ doAssign (PhpVar target) (PhpConst(PhpConstNumber (float index))) ]
        | _ ->
            let idents,target = com.DecisionTargets.[index]
            [ for ident, boundValue in List.zip idents boundValues do
                com.AddLocalVar(fixName ident.Name, ident.IsMutable)
                doAssign (PhpVar(fixName ident.Name)) (convertExpr com boundValue)
              yield! convertExprToStatement com target returnStrategy ]

    | Fable.Let(ident, expr,body) ->
        [
          let name = fixName ident.Name
          com.AddLocalVar(name, ident.IsMutable)
          yield! convertExprToStatement com expr (Let name)
          yield! convertExprToStatement com body returnStrategy ]

    | Fable.Sequential(exprs) ->
        if List.isEmpty exprs then
            []
        else
            [ for expr in exprs.[0..exprs.Length-2] do
                    yield! convertExprToStatement com expr Do
              yield! convertExprToStatement com exprs.[exprs.Length-1] returnStrategy
                    ]
    | Fable.Set(expr,kind,_typ,value,_) ->
        let left = convertExpr com expr

        let leftAssign =
            match kind with
            | Fable.SetKind.ValueSet ->
                match left with
                | PhpVar v ->
                    com.AddLocalVar(v, true)
                | _ -> ()
                left
            | Fable.SetKind.FieldSet(fieldName) ->
                phpField left (fixName fieldName)
            | Fable.SetKind.ExprSet(keyExpr) ->
                PhpArrayAccess(left, convertExpr com keyExpr)


        [ doAssign(leftAssign) (convertExpr com value)]
    | Fable.TryCatch(body,catch,finallizer,_) ->
        [PhpTryCatch(convertExprToStatement com body returnStrategy,
                    (match catch with
                    | Some(id,expr) -> Some(id.DisplayName, convertExprToStatement com expr returnStrategy)
                    | None -> None),
                    match finallizer with
                    | Some expr -> convertExprToStatement com expr Do
                    | None -> []
            )]

    | Fable.WhileLoop(guard, body, label,_) ->
        com.EnterBreakable label
        let phpGuard = convertExpr com guard
        let phpBody = convertExprToStatement com body Do
        com.LeaveBreakable()
        [ PhpWhileLoop(phpGuard, phpBody ) ]
    | Fable.ForLoop(ident, start, limit, body, isUp, _) ->
        com.EnterBreakable None
        let id = fixName ident.Name
        let startExpr =  convertExpr com start
        com.AddLocalVar(id, false)
        let limitExpr = convertExpr com limit
        let bodyExpr = convertExprToStatement com body Do
        com.LeaveBreakable()

        [ PhpFor(id,startExpr, limitExpr, isUp, bodyExpr)]



    | Fable.NativeInstruction(Fable.Break label,_) ->
        let phpLevel =
            match label with
            | Some lbl -> com.FindLableLevel lbl |> Some
            | None -> None
        [ PhpBreak phpLevel ]
    | Fable.NativeInstruction(Fable.Debugger, _) ->
        [ PhpDo (PhpCall(PhpIdent (ident "assert"), [ PhpConst (PhpConstBool false)])) ]
    | Fable.NativeInstruction(Fable.Throw(expr, _ ),_) ->
            [ PhpThrow(convertExpr com expr)]


    | _ ->
        let fixThrow ret expr =
            match expr with
            | PhpCall(PhpAnonymousFunc([], _, [PhpThrow(_) as phpThrow]),[]) -> [phpThrow]
            | phpExpr -> [ ret phpExpr ]


        match returnStrategy with
        | Return ->

            convertExpr com expr
            |> fixThrow PhpReturn
        | Let(var) ->
            com.AddLocalVar(var, false)
            [ doAssign (PhpVar var) (convertExpr com expr) ]
        | Do ->
            match expr with
            | Fable.Value(Fable.UnitConstant, _) -> []
            | Fable.Operation(Fable.Unary(UnaryVoid, expr), _, _) -> [ PhpStatement.PhpDo ( convertExpr com expr ) ]
            | _ ->
                convertExpr com expr
                |> fixThrow PhpDo

        | Target _ -> failwithf "Target should be assigned by decisiontree success"

and convertMemberDecl (com: IPhpCompiler) (decl: Fable.MemberDecl) : PhpMethod =

    let name =
        fixName decl.Name //.Substring(typ.Name.Length + 2) |> fixName


    let oldThis =
        if decl.Info.IsInstance && not (List.isEmpty decl.Args)  then
            fixName decl.Args.[0].Name |> Some
        else
            None
        |> com.SetThisArgument


    let strategy =
        match decl.Body.Type with
        | Fable.Unit -> Do
        | _ -> Return

    let body = convertExprToStatement com decl.Body strategy
    com.RestoreThisArgument(oldThis)

    makeMethod' name
            [ for arg in decl.Args.[1..] do
                 match arg.Type with
                 | Fable.Unit -> ()
                 | _ ->
                    phpArg (fixName arg.Name) ]
                body
                (not decl.Info.IsInstance)


let filterUnit = List.filter (fun (arg: Fable.Ident) -> arg.Type <> Fable.Unit )

let convertParams (ps: Fable.Ident list) =
    [ for p in filterUnit ps do

        { Name = fixName p.Name
          Kind = if p.IsOptional then
                    PhpOptionalArg
                 else
                    PhpMandatoryArg }
        ]

let makeGetIterator com =
    makeMethod "getIterator" []
        [ PhpReturn ( libCall com "Util" "Util" "toIterator" [ callmethod phpThis "GetEnumerator" []]) ]


let rec convertDecl (com: IPhpCompiler)  decl : PhpNamespace =
    match decl with
    | Fable.Declaration.ClassDeclaration decl ->
        convertClass com decl
    | Fable.Declaration.MemberDeclaration decl ->
        com.AddImport(decl.Name, decl.Info.IsValue)
        let phpDecl =
            if decl.Info.IsValue then
                //[ PhpDeclValue(fixName decl.Name, convertExpr com decl.Body) ]
                let name = fixName decl.Name
                makeFun name
                            []
                            [  match convertExpr com decl.Body with
                               | PhpConst _ as value ->
                                PhpReturn value
                               | value ->
                                PhpStaticVar(name, None)
                                PhpReturn(PhpBinaryOp("??", PhpVar name, assign (PhpVar name) value))
                            ]
            else
                let strategy =
                    match decl.Body.Type with
                    | Fable.Unit -> Do
                    | _ -> Return

                let body = convertExprToStatement com decl.Body strategy

                makeFun (fixName decl.Name) (convertParams decl.Args)
                          body
        { Namespace = Some com.PhpNamespace
          Decls = [ PhpFun phpDecl ] }

    | Fable.Declaration.ActionDeclaration decl ->
        { Namespace = Some com.PhpNamespace
          Decls = [ PhpAction( convertExprToStatement com decl.Body Do ) ] }

    | Fable.ModuleDeclaration decl ->
        failwith "Not implemented"

and convertClass (com: IPhpCompiler) (decl: Fable.ClassDecl) =
    let ent = com.GetEntity(decl.Entity)
    let id =
        getEntityIdent ent

    com.AddEntityName(ent, id.Name)

    let ns =
        if ent.IsFSharpUnion then
            convertUnion com decl ent
        elif ent.IsFSharpRecord then
            convertRecord com decl ent
        else
            let baseType =
                ent.BaseType
                |> Option.map (fun b -> getEntityRefIdent com b.Entity)

            let baseCall =
                decl.BaseCall
                |> Option.toList
                |> List.collect (fun expr ->
                    match expr with
                    | Fable.Call(_,info,_,_) ->
                        [ PhpDo (call (PhpMember(PhpParentMember, "__construct", PhpMethod)) (convertArgs com info.Args) ) ]
                    | _ -> convertExprToStatement com expr Do
                        )

            let phpCtor =
                decl.Constructor
                |> Option.map (fun ctor ->
                    let rec simplifyCtor expr =
                        match expr with
                        | Fable.Sequential (Fable.ObjectExpr([],_,_) ::  rest ) ->
                            simplifyCtor (Fable.Sequential rest)
                        | Fable.Sequential (Fable.Value (Fable.UnitConstant, _) :: rest) ->
                            simplifyCtor (Fable.Sequential rest)
                        | _ -> expr

                    makeMethod "__construct" (convertParams ctor.Args)
                                 [ yield! convertExprToStatement com (simplifyCtor ctor.Body) Do
                                   yield! baseCall ]
                )
                |> Option.orElseWith (fun() ->
                    match baseCall with
                    | [] -> None
                    | _ -> Some (makeMethod "__construct" [] baseCall)
                )

            let hasIterator =
                decl.AttachedMembers |> List.exists (fun m -> m.Info.IsEnumerator);



            let typ =
                {
                    Identity = id
                    Class = {
                        Fields = [ for field in ent.FSharpFields -> fixName field.Name ]
                        Methods = [ yield! Option.toList phpCtor
                                    for mdecl in decl.AttachedMembers do

                                        yield convertMemberDecl com mdecl
                                    if hasIterator then
                                        yield
                                            makeGetIterator com
                                    ]
                        BaseType = baseType
                        Interfaces =
                            if hasIterator then
                                [ Core.traversable ]

                            else
                                []
                    }
                    Abstract = false
                 }

            { Namespace = id.Namespace
              Decls = [PhpType typ] }

    ns
/// creates Php classes for an F# union type
and convertUnion (com: IPhpCompiler) (decl: Fable.ClassDecl) (info: Fable.Entity) =
    if info.UnionCases.Length = 1 then
        convertSingleCaseUnion com decl info
    else
        convertMultiCaseUnion com decl info

/// creates Php class for a F# record
and convertRecord (com: IPhpCompiler) (decl: Fable.ClassDecl) (info: Fable.Entity) =
    let nocomparison =
        info.Attributes
        |> Seq.exists(fun a -> a.Entity.FullName = Atts.noComparison)

    let customComparison =
        info.Attributes
        |> Seq.exists(fun a -> a.Entity.FullName = Atts.customComparison)
    let id = getEntityIdent info
    let hasIterator =
        decl.AttachedMembers |> List.exists (fun m -> m.Info.IsEnumerator);

    let t =
        { Identity = id
          Class = {
              Fields = [ for e in info.FSharpFields -> fixName e.Name ]
              Methods = [
                  makeMethod "__construct" [ for e in info.FSharpFields ->  phpArg (fixName e.Name) ]
                          [ for e in info.FSharpFields ->
                                let name = fixName e.Name
                                doAssign (phpField phpThis name) (PhpVar name ) ]
                  if not (customComparison || nocomparison) then
                      makeMethod "CompareTo" [ phpArg "other"]
                              [ for e in info.FSharpFields do
                                    let cmp = PhpVar(com.MakeUniqueVar "cmp")
                                    let fieldName = fixName e.Name
                                    match e.FieldType with
                                    | Fable.Number _
                                    | Fable.String ->
                                        doAssign cmp
                                            (PhpTernary( PhpBinaryOp(">",
                                                            phpField phpThis fieldName,
                                                            phpField (PhpVar "other") fieldName),
                                                            PhpConst(PhpConstNumber 1.),
                                                               PhpTernary(
                                                                   PhpBinaryOp("<",
                                                                       phpField phpThis fieldName,
                                                                       phpField (PhpVar "other") fieldName),
                                                                       PhpConst(PhpConstNumber -1.),
                                                                        PhpConst(PhpConstNumber 0.)


                                           ) ) )
                                    | _ ->
                                        doAssign cmp
                                            (callmethod(phpField phpThis fieldName) "CompareTo"
                                                      [phpField (PhpVar "other") fieldName ])

                                    PhpIf(PhpBinaryOp("!=", cmp, PhpConst(PhpConstNumber 0.) ),
                                        [PhpStatement.PhpReturn cmp],
                                        []
                                    )
                                PhpStatement.PhpReturn (PhpConst (PhpConstNumber 0.))
                              ]
                  for d in decl.AttachedMembers do
                    convertMemberDecl com d
                  if hasIterator then
                    makeGetIterator com

                    ]
              BaseType = None
              Interfaces =
                [ if not nocomparison then
                    Core.icomparable
                  if hasIterator then
                    Core.traversable ]
            }
          Abstract = false
          }
    if not nocomparison then
        com.AddUse(Core.icomparable)
    { Namespace = id.Namespace
      Decls = [ PhpType t]
    }

/// creates the class for a F# single case union.
and convertSingleCaseUnion (com: IPhpCompiler) (decl: Fable.ClassDecl) (info: Fable.Entity) =
    let nocomparison =
        info.Attributes
        |> Seq.exists(fun a -> a.Entity.FullName = Atts.noComparison)

    let customComparison =
        info.Attributes
        |> Seq.exists(fun a -> a.Entity.FullName = Atts.customComparison)

    let case = info.UnionCases.[0]
    let id = getEntityIdent info
    let hasIterator =
        decl.AttachedMembers |> List.exists (fun m -> m.Info.IsEnumerator);

    let t =
        { Identity = id
          Class = {
              Fields = [ for e in case.UnionCaseFields -> fixName e.Name ]
              Methods = [
                  makeMethod "__construct" [ for e in case.UnionCaseFields -> phpArg  (fixName e.Name) ]
                            [ for e in case.UnionCaseFields ->
                                let name = fixName e.Name
                                doAssign (phpField phpThis name) (PhpVar name)
                            ]


                  makeMethod "get_FSharpCase" [] [ PhpStatement.PhpReturn(PhpConst(PhpConstString(case.Name)))]
                  makeMethod "get_Tag" [] [ PhpStatement.PhpReturn(PhpConst(PhpConstNumber(0.)))]
                  if not (nocomparison || customComparison) then
                      makeMethod "CompareTo" [ phpArg "other"]
                              [ for e in case.UnionCaseFields do
                                    let cmp = PhpVar (com.MakeUniqueVar "cmp")
                                    let fieldName = fixName e.Name
                                    match e.FieldType with
                                    | Fable.Type.Number _ ->
                                        doAssign cmp
                                            ( PhpTernary( PhpBinaryOp(">",
                                                            phpField phpThis fieldName,
                                                            phpField (PhpVar "other") fieldName),
                                                            PhpConst(PhpConstNumber 1.),
                                                               PhpTernary(
                                                                   PhpBinaryOp("<",
                                                                       phpField phpThis fieldName,
                                                                       phpField (PhpVar "other") fieldName),
                                                                       PhpConst(PhpConstNumber -1.),
                                                                        PhpConst(PhpConstNumber 0.)


                                           ) ))
                                    | _ ->
                                        doAssign cmp
                                            (callmethod (phpField phpThis fieldName) "CompareTo"
                                                        [phpField (PhpVar "other") fieldName ])


                                    PhpIf(PhpBinaryOp("!=", cmp, PhpConst(PhpConstNumber 0.) ),
                                        [PhpStatement.PhpReturn cmp],
                                        []
                                    )
                                PhpStatement.PhpReturn (PhpConst (PhpConstNumber 0.))
                              ]
                  for mdecl in decl.AttachedMembers do
                        convertMemberDecl com mdecl
                  if hasIterator then
                    makeGetIterator com
              ]
              BaseType = None
              Interfaces = [ if not nocomparison then
                                Core.icomparable
                             if hasIterator then
                                Core.traversable ]
              }
          Abstract = false
        }
    if not nocomparison then
        com.AddUse(Core.icomparable)
    { Namespace = id.Namespace
      Decls = [ PhpType t]}



type Scope =
    { mutable capturedVars: Capture Set
      mutable localVars: string Set
      mutable mutableVars: string Set
      parent : Scope option
    }


    static member create(parent) =
        { capturedVars = Set.empty
          localVars = Set.empty
          mutableVars = Set.empty
          parent = parent
          }


type PhpCompiler(com: Fable.Compiler) =
    let mutable types = Map.empty
    let mutable decisionTargets = []
    let mutable scope = Scope.create(None)
    let mutable id = 0
    let mutable isImportValue = Map.empty
    let mutable classNames = Map.empty
    let mutable basePath = ""
    let mutable require = Set.empty
    let mutable nsUse = Set.empty
    let mutable phpNamespace = ""
    let mutable thisArgument = None
    let mutable breakable = []

    member this.AddType(entref: Fable.EntityRef option, phpType: PhpType) =
        let name =
            match entref with
            | Some entref ->
                let ent = com.GetEntity(entref)
                ent.FullName
            | None -> phpType.Identity.Name
        types <- Map.add name phpType types

    member this.AddLocalVar(var, isMutable) =
        if isMutable then
            scope.mutableVars <- Set.add var scope.mutableVars

        if scope.capturedVars.Contains(Capture.ByRef var) then
            ()
        elif scope.capturedVars.Contains(Capture.ByValue var) then
            scope.capturedVars <- scope.capturedVars |> Set.remove (Capture.ByValue var)  |> Set.add(ByRef var)
        else
            scope.localVars <- Set.add var scope.localVars

    member this.UseVar(var) =
        if not (Set.contains var scope.localVars) && not (Set.contains (ByRef var) scope.capturedVars) then
            if Set.contains var scope.mutableVars then
                scope.capturedVars <- Set.add (ByRef var) scope.capturedVars
            else
                scope.capturedVars <- Set.add (ByValue var) scope.capturedVars


    member this.UseVarByRef(var) =
        scope.mutableVars <- Set.add var scope.mutableVars
        if not (Set.contains var scope.localVars) && not (Set.contains (ByRef var) scope.capturedVars) then
            scope.capturedVars <- Set.add (ByRef var) (Set.remove (ByValue var) scope.capturedVars)

    member this.UseVar(var) =
        match var with
        | ByValue name -> this.UseVar name
        | ByRef name -> this.UseVarByRef name

    member this.MakeUniqueVar(name) =
        id <- id + 1
        "_" + name + "__" + string id

    member this.NewScope() =
        let oldScope = scope
        scope <- Scope.create(Some oldScope)

    member this.RestoreScope() =
        match scope.parent with
        | Some p ->
            let vars = scope.capturedVars
            scope <- p
            for capturedVar in vars do
                this.UseVar(capturedVar)

            Set.toList vars

        | None -> failwith "Already at top scope"

    member this.AddImport(name, isValue) =
        isImportValue <- Map.add name isValue isImportValue

    member this.AddEntityName(entity: Fable.Entity, name) =
        classNames <- Map.add entity.FullName name classNames

    member this.GetEntityName(e: Fable.Entity) =
        match Map.tryFind e.FullName classNames with
        | Some n -> n
        | None -> e.DisplayName

    member this.AddRequire(file: string) =

        if file.Contains "fable-library" then
            let path = Path.GetFileName (fixExt file)
            require <- Set.add (Some "__FABLE_LIBRARY__",  "/" + path) require

        else
            let fullPhpPath =
                let p = fixExt file
                if Path.IsPathRooted p then
                    p
                else
                    Path.GetFullPath(Path.Combine(Path.GetDirectoryName(com.CurrentFile), p))

            if fullPhpPath <> com.CurrentFile then
                let path =
                    let p = Path.getRelativePath basePath fullPhpPath
                    if p.StartsWith "./" then
                        p.Substring 2
                    else
                        p

                require <- Set.add (Some "__ROOT__" , "/" + path) require


    member this.ClearRequire(path) =
        basePath <- path
        require <- Set.empty
        nsUse <- Set.empty

    member this.AddUse(typ: PhpType) =
        nsUse <- Set.add typ nsUse;

    member this.SetPhpNamespace(ns) =
        phpNamespace <- ns

    member this.TryFindType(name: string) =
        Map.tryFind name types

    member this.TryFindType(ref: Fable.EntityRef) =
        let ent = com.GetEntity(ref)
        match this.TryFindType(ent.FullName) with
        | Some t -> Ok t
        | None -> Error ent

    member this.IsThisArgument(id: Fable.Ident) =
        if id.IsThisArgument then
            true
        else
            let name = fixName id.Name
            if Some name = thisArgument then
                true
            else
                false


    member this.IsImport(name: string) =
        Map.tryFind name isImportValue


    interface IPhpCompiler with
        member this.AddType(entref, phpType: PhpType) = this.AddType(entref, phpType)
        member this.AddLocalVar(var, isMutable) = this.AddLocalVar(var, isMutable)
        member this.UseVar(var: Capture) = this.UseVar(var)
        member this.UseVarByRef(var) = this.UseVarByRef(var)
        member this.UseVar(var: string) = this.UseVar(var)
        member this.MakeUniqueVar(name) = this.MakeUniqueVar(name)
        member this.NewScope() = this.NewScope()
        member this.RestoreScope() = this.RestoreScope()
        member this.AddImport(name, isValue) = this.AddImport(name, isValue)
        member this.IsImport(name) = this.IsImport(name)
        member this.AddEntityName(entity: Fable.Entity, name) = this.AddEntityName(entity, name)
        member this.ClearRequire(path) = this.ClearRequire(path)
        member this.AddUse(typ: PhpType) = this.AddUse(typ)
        member this.SetPhpNamespace(ns) = this.SetPhpNamespace(ns)
        member this.TryFindType(entity: Fable.EntityRef) = this.TryFindType(entity)
        member this.TryFindType(name: string) = this.TryFindType(name)
        member this.IsThisArgument(id) = this.IsThisArgument(id)
        member this.DecisionTargets = decisionTargets
        member this.SetDecisionTargets value = decisionTargets <- value
        member this.SetThisArgument value =
            let oldThis = thisArgument
            thisArgument <- value
            oldThis
        member this.RestoreThisArgument(old)= thisArgument <- old
        member this.PhpNamespace = phpNamespace
        member this.Require = Set.toList require
        member this.NsUse = Set.toList nsUse

        member this.AddLog(msg,severity, rang, fileName, tag) = com.AddLog(msg,severity, ?range = rang, ?fileName= fileName, ?tag = tag)
        member this.AddWatchDependency(file) = com.AddWatchDependency(file)
        member this.GetEntity(e) = com.GetEntity(e)
        member this.GetImplementationFile(fileName) = com.GetImplementationFile(fileName)
        member this.GetOrAddInlineExpr(name, p ) = com.GetOrAddInlineExpr(name, p)
        member this.LibraryDir = com.LibraryDir
        member this.CurrentFile = com.CurrentFile
        member this.OutputDir = com.OutputDir
        member this.ProjectFile = com.ProjectFile
        member this.Options = com.Options
        member this.Plugins = com.Plugins
        member this.GetRootModule(fileName) = com.GetRootModule(fileName)
        member this.EnterBreakable(label) = breakable <- label :: breakable
        member this.LeaveBreakable() =
            breakable <- List.tail breakable
        member this.FindLableLevel(label) =
            List.findIndex(function Some v when v = label -> true | _ -> false) breakable


let transformFile com (file: Fable.File) =
    let phpComp = PhpCompiler(com) :> IPhpCompiler
    phpComp.ClearRequire(__SOURCE_DIRECTORY__ + @"/src/")

    let rootModule = com.GetRootModule(phpComp.CurrentFile)
    phpComp.SetPhpNamespace(nsreplacement rootModule)
    let decls =
        [
            for decl in file.Declarations do
                let decls =
                    try
                        convertDecl phpComp decl
                    with
                    |    ex ->
                        eprintfn "Error while transpiling decl: %O"  ex
                        reraise()
                yield decls
        ]
        |> List.groupBy (fun ns -> ns.Namespace)
        |> List.map (fun (ns, parts) ->
            { Namespace = ns
              Decls = parts |> List.collect (fun p -> p.Decls)
            }
        )


    { Filename = phpComp.CurrentFile + ".php"
      Uses = phpComp.NsUse
      Namespaces = decls }
